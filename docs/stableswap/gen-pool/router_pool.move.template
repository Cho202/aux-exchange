{{.WarningForManualEdit}}
/// helpers for stable pool
module aux::router_{{.N}}pool {
{{$lastIndex := .LastIndex}}{{$typeList := .CoinTypeList}}    use std::signer;

    use aptos_framework::coin;

    use aux::stable_{{.N}}pool;

    /**************************/
    /* Entry Function Wrapper */
    /**************************/

    public entry fun add_liquidity<{{.CoinTypeList}}>(
        sender: &signer,
        {{range .Xis}}coin_{{.I}}_amount: u64,
        {{end}}min_lp_amount: u64,
    ) {
        let sender_addr = signer::address_of(sender);
{{range .Xis}}
        let coin_{{.I}} = if (coin_{{.I}}_amount > 0) {
            coin::withdraw<Coin{{.I}}>(sender, coin_{{.I}}_amount)
        } else {
            coin::zero<Coin{{.I}}>()
        };
{{end}}
        let lp_tokens = stable_{{.N}}pool::add_liquidity(
            sender_addr,
            {{range .Xis}}coin_{{.I}},
            {{end}}min_lp_amount,
        );

        if (!coin::is_account_registered<stable_{{.N}}pool::LP<{{.CoinTypeList}}>>(sender_addr)) {
            coin::register<stable_{{.N}}pool::LP<{{.CoinTypeList}}>>(sender);
        };
        coin::deposit(sender_addr, lp_tokens);
    }

    public entry fun remove_liquidity_for_coin<{{.CoinTypeList}}>(
        sender: &signer,
        {{range .Xis}}amount_{{.I}}_to_withdraw: u64,
        {{end}}lp_amount: u64,
    ) {
        let lp = coin::withdraw<stable_{{.N}}pool::LP<{{.CoinTypeList}}>>(sender, lp_amount);
        let sender_addr = signer::address_of(sender);

        let ({{range .Xis}}coin_{{.I}}, {{end}}lp) = stable_{{.N}}pool::remove_liquidity_for_coin<{{.CoinTypeList}}>(
            sender_addr,
            {{range .Xis}}amount_{{.I}}_to_withdraw,
            {{end}}lp,
        );
{{range .Xis}}
        if (coin::value(&coin_{{.I}}) > 0) {
            if (!coin::is_account_registered<Coin{{.I}}>(sender_addr)) {
                coin::register<Coin{{.I}}>(sender);
            };
            coin::deposit(sender_addr, coin_{{.I}});
        } else {
            coin::destroy_zero(coin_{{.I}});
        };
{{end}}
        if (coin::value(&lp) == 0) {
            coin::destroy_zero(lp);
        } else {
            coin::deposit(sender_addr, lp);
        }
    }

    public entry fun remove_liquidity<{{.CoinTypeList}}>(
        sender: &signer,
        lp_amount: u64,
    ) {
        let lp = coin::withdraw<stable_{{.N}}pool::LP<{{.CoinTypeList}}>>(sender, lp_amount);
        let sender_addr = signer::address_of(sender);

        let ({{range .Xis}}coin_{{.I}}{{if .NotLast}}, {{end}}{{end}}) = stable_{{.N}}pool::remove_liquidity<{{.CoinTypeList}}>(sender_addr, lp);
{{range .Xis}}
        if (coin::value(&coin_{{.I}}) > 0) {
            if (!coin::is_account_registered<Coin{{.I}}>(sender_addr)) {
                coin::register<Coin{{.I}}>(sender);
            };
            coin::deposit(sender_addr, coin_{{.I}});
        } else {
            coin::destroy_zero(coin_{{.I}});
        };
{{end}}    }

    public entry fun swap_exact_coin_for_coin<{{.CoinTypeList}}>(
        sender: &signer,
        {{range .Xis}}coin_{{.I}}_amount: u64,
        {{end}}out_coin_index: u8,
        min_quantity_out: u64,
    ) {
        let sender_addr = signer::address_of(sender);
{{range .Xis}}
        let coin_{{.I}} = if (coin_{{.I}}_amount > 0) {
            coin::withdraw<Coin{{.I}}>(sender, coin_{{.I}}_amount)
        } else {
            coin::zero<Coin{{.I}}>()
        };
{{end}}
        let ({{range .Xis}}coin_{{.I}}{{if .NotLast}}, {{end}}{{end}}) = stable_{{.N}}pool::swap_exact_coin_for_coin(
            sender_addr,
            {{range .Xis}}coin_{{.I}},
            {{end}}out_coin_index,
            min_quantity_out,
        );
{{range .Xis}}
        if (coin::value(&coin_{{.I}}) > 0) {
            if (!coin::is_account_registered<Coin{{.I}}>(sender_addr)) {
                coin::register<Coin{{.I}}>(sender);
            };
            coin::deposit(sender_addr, coin_{{.I}});
        } else {
            coin::destroy_zero(coin_{{.I}});
        };
{{end}}    }

    public entry fun swap_coin_for_exact_coin<{{.CoinTypeList}}>(
        sender: &signer,
        {{range .Xis}}requested_quantity_{{.I}}: u64,
        {{end}}in_coin_index: u8,
        max_in_coin_amount: u64,
    ) {
        let sender_addr = signer::address_of(sender);
{{range .Xis}}
        let coin_{{.I}} = if (in_coin_index == {{.I}}) {
            coin::withdraw<Coin{{.I}}>(sender, max_in_coin_amount)
        } else {
            coin::zero<Coin{{.I}}>()
        };
{{end}}
        let ({{range .Xis}}coin_{{.I}}{{if .NotLast}}, {{end}}{{end}}) = stable_{{.N}}pool::swap_coin_for_exact_coin(
            sender_addr,
            {{range .Xis}}coin_{{.I}},
            requested_quantity_{{.I}},
            {{end}}in_coin_index,
        );
{{range .Xis}}
        if (coin::value(&coin_{{.I}}) > 0) {
            if (!coin::is_account_registered<Coin{{.I}}>(sender_addr)) {
                coin::register<Coin{{.I}}>(sender);
            };
            coin::deposit(sender_addr, coin_{{.I}});
        } else {
            coin::destroy_zero(coin_{{.I}});
        };
{{end}}    }

    public entry fun remove_coin<{{.CoinTypeList}}>(
        sender: &signer,
{{range .Xis}}        amount_{{.I}}_to_withdraw: u64,
{{end}}    ) {
        let sender_addr = signer::address_of(sender);
        let lp_amount = coin::balance<stable_{{.N}}pool::LP<{{.CoinTypeList}}>>(sender_addr);
        remove_liquidity_for_coin<{{.CoinTypeList}}>(
            sender,
            {{range .Xis}}amount_{{.I}}_to_withdraw,
            {{end}}lp_amount,
        );
    }
}
