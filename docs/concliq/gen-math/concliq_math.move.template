// Autogenerated from ./docs/concliq/gen-math -p {{.Precision}}
// Manual edit with caution.
//
// Tick math for concentrated liquidity.
// square price is an u128 used as a fixed point number.
// Precision indicates how many bits are after decimal point.
// There are three optiosn for precision:
// - 32: only lower 64 bits of the u128 is used, decimal point is at index 96 of the u128 from the most significant bit.
// - 64: only lower 96 bits of the u128 is used, decimal point is at index 64 of the u128 from the most significant bit.
// - 96: all the bits of the u128 is used, decimal point is at index 32 of teh u128 from the most significant bit.
module aux::concliq_math {
    use aux::uint256;
    use aux::int64::{Self, Int64};
    use aux::int128::{Self, Int128};

    /**********************/
    /* Errors             */
    /**********************/

    const E_TICK_TOO_BIG: u64 = 1001;
    const E_TICK_TOO_SMALL: u64 = 1002;
    const E_Y_OUTSIDE_1_2: u64 = 1003;
    const E_ZERO_FOR_LOG_2: u64 = 1004;
    const E_Y_LESS_THAN_ONE: u64 = 1004;

    /**********************/
    /* constants          */
    /**********************/

    /// Precision used in the operation.
    const PRECISION: u8 = {{.Precision}};

    const OFFSET_96: u8 = 96 - {{.Precision}};

    const ONE_X: u128 = 1 << {{.Precision}};
    const TWO_X: u128 = 1 << ({{.Precision}} + 1);

    /// sqrt(1.0001) in fixed point {{.Precision}}
    const SQUARE_PRICE: u128 = {{.SquarePrice1}};
    /// log_2 sqrt(1.0001) in fixed point {{.Precision}}
    const SQUARE_PRICE_LOG_2: u128 = {{.SquarePrice1Log2}};
    /// 1/sqrt(1.0001)
    const SQUARE_PRICE_NEG: u128 = {{.SquarePriceNeg1}};
    /// log_2 1/sqrt(1.0001)
    const SQUARE_PRICE_NEG_LOG_2_ABS: u128 = {{.SquarePriceNeg1Log2}};

    /// get sqrt(1.0001)^i
    public fun get_square_price_from_tick(i: Int64): u128 {
        if (int64::is_negative(i)) {
            get_square_price_from_tick_negative(int64::abs(i))
        } else {
            get_square_price_from_tick_positive(int64::raw_value(i))
        }
    }

    /// get sqrt(1.0001)^i, where i >= 0
    public fun get_square_price_from_tick_positive(i: u64): u128 {
        assert!(i <= {{.MaxPositiveIndex}}, E_TICK_TOO_BIG);
        let r = uint256::new(0, ONE_X);
{{range .PositiveIndices}}
        // check for 2^{{.I}}
        if (i & {{.TwoP}} > 0) {
            r = uint256::multiply_underlying(r, {{.StringV}});
            r = uint256::rsh(r, PRECISION);
        };
{{end}}
        uint256::downcast(r)
    }

    /// get sqrt(1.0001)^(-i), where i >= 0
    public fun get_square_price_from_tick_negative(i: u64): u128 {
        assert!(i <= {{.MinNegativeIndex}}, E_TICK_TOO_BIG);
        let r = uint256::new(0, ONE_X);
{{range .NegativeIndices}}        if (i & {{.TwoP}} > 0) {
            r = uint256::multiply_underlying(r, {{.StringV}});
            r = uint256::rsh(r, PRECISION);
        };
{{end}}
        uint256::downcast(r)
    }

    /// get log_2 y where y \in [1,2)
    public fun log_2_y(y: u128): u128 {
        assert!(y >= ONE_X && y < TWO_X, E_Y_OUTSIDE_1_2);
        let z_2: u128 = y;
        let r: u128 = 0;
        let sum_m: u8 = 0;
        let m: u8 = 0;

        loop {
            if (z_2 == ONE_X) {
                break
            };
            let z = uint256::underlying_mul_to_uint256(z_2, z_2);
            z = uint256::rsh(z, PRECISION);
            let z = uint256::downcast(z);
            sum_m = sum_m + 1;
            m = m + 1;
            if (sum_m > PRECISION) {
                break
            };
            if (z >= TWO_X) {
                r = r + (ONE_X >> sum_m);
                z_2 = z >> 1;
            } else {
                z_2 = z;
            };
        };

        r
    }

    public fun log_2(y: u128): Int128 {
        assert!(y != 0, E_ZERO_FOR_LOG_2);
        let leading_zeros = uint256::underlying_leading_zeros(y);
        if (y == ONE_X) {
            int128::zero()
        } else if (y > ONE_X) {
            let n_0: u8 = 128 - PRECISION - leading_zeros - 1;
            let r = (n_0 as u128) << PRECISION;
            int128::new(r + log_2_y(y >> n_0), false)
        } else {
            let n_0: u8 = leading_zeros - (128 - PRECISION - 1);
            let r = (n_0 as u128) << PRECISION;
            let intpart = int128::new(r, true);
            int128::add(int128::new(log_2_y(y << n_0), false), intpart)
        }
    }

    public fun get_tick(sqrt_p: u128): Int64 {
        let log_2_y = log_2(sqrt_p);
        let is_neg = int128::is_negative(log_2_y);
        let log_2_y = int128::abs(log_2_y);
        let ratio = if (is_neg) {
            let r = log_2_y / SQUARE_PRICE_NEG_LOG_2_ABS;
            if (r * SQUARE_PRICE_NEG_LOG_2_ABS < log_2_y) {
                r + 1
            } else {
                r
            }
        } else {
            log_2_y / SQUARE_PRICE_LOG_2        
        };
        int64::new((ratio as u64), is_neg)
    }

    #[test_only]
    public fun get_square_price_from_2_n_positive(i: u8): u128 {
{{range .PositiveIndices}}        {{if ne .I 0}}} else {{end}}if (i == {{.I}}) {
            {{.StringV}}
{{end}}        } else {
            abort((i as u64))
        }
    }
    #[test_only]
    public fun get_square_price_from_2_n_negative(i: u8): u128 {
{{range .NegativeIndices}}        {{if ne .I 0}}} else {{end}}if (i == {{.I}}) {
            {{.StringV}}
{{end}}        } else {
            abort((i as u64))
        }
    }

    #[test]
    fun test_log_2_y() {
        assert!(int128::is_zero(log_2(ONE_X)), 1);
{{range .PositiveIndices}}
        // check positive side
        let square_price_{{.I}} = {{.StringV}}u128;
        let ratio_{{.I}} = get_tick(square_price_{{.I}});
        let abs_ratio_{{.I}} = int64::abs(ratio_{{.I}});
        assert!(abs_ratio_{{.I}} == {{.TwoP}}, abs_ratio_{{.I}});
{{end}}
{{range .NegativeIndices}}        // check negative side
        let square_price_{{.I}} = {{.StringV}}u128;
        let ratio_{{.I}} = get_tick(square_price_{{.I}});
        let abs_ratio_{{.I}} = int64::abs(ratio_{{.I}});
        assert!(abs_ratio_{{.I}} == {{.TwoP}}, abs_ratio_{{.I}});
{{end}}    }
}
