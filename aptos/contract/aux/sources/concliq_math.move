// Autogenerated from ./docs/concliq/gen-math -p 96
// Manual edit with caution.
//
// Tick math for concentrated liquidity.
// square price is an u128 used as a fixed point number.
// Precision indicates how many bits are after decimal point.
// There are three optiosn for precision:
// - 32: only lower 64 bits of the u128 is used, decimal point is at index 96 of the u128 from the most significant bit.
// - 64: only lower 96 bits of the u128 is used, decimal point is at index 64 of the u128 from the most significant bit.
// - 96: all the bits of the u128 is used, decimal point is at index 32 of the u128 from the most significant bit.
module aux::concliq_math {
    use aux::int32::{Self, Int32};
    use aux::int128::{Self, Int128};
    use aux::more_math_u256;
    use aux::more_math_u128;

    /**********************/
    /* Errors             */
    /**********************/

    const E_TICK_TOO_BIG: u64 = 1001;
    const E_TICK_TOO_SMALL: u64 = 1002;
    const E_Y_OUTSIDE_1_2: u64 = 1003;
    const E_ZERO_FOR_LOG_2: u64 = 1004;
    const E_Y_LESS_THAN_ONE: u64 = 1004;

    /**********************/
    /* constants          */
    /**********************/

    /// Precision used in the operation.
    const PRECISION: u8 = 96;

    // ONE_X is 1 in fixed point number with 96 digits after decimal point.
    const ONE_X: u128 = 1 << 96;
    // TWO_X is 2 in fixed point number with 96 digits after decimal point.
    const TWO_X: u128 = 1 << (96 + 1);
    // ONE_X_256 is 1 in fixed point number with 96 digits after decimal point.
    const ONE_X_256: u256 = 1 << 96;
    // TWO_X_256 is 2 in fixed point number with 96 digits after decimal point.
    const TWO_X_256: u256 = 1 << (96 + 1);
    // ONE_X_TWICE_SHIFTED_256 is 1 in fixed point number with 2*96 digits after decimal point. It is generally acting as numerator for division.
    const ONE_X_TWICE_SHIFTED_256: u256 = (1 << 96) << 96;

    /// sqrt(1.0001) in fixed point 96
    const SQUARE_PRICE: u128 = 79232123823359799118286999567;
    /// log_2 sqrt(1.0001) in fixed point 96
    const SQUARE_PRICE_LOG_2: u128 = 5714818121759723666406290;
    /// 1/sqrt(1.0001)
    const SQUARE_PRICE_NEG: u128 = 79224201403219477170569942573;
    /// log_2 1/sqrt(1.0001)
    const SQUARE_PRICE_NEG_LOG_2_ABS: u128 = 5714818121759723666406293;

    /// get sqrt(1.0001)^i
    public fun get_square_price_from_tick(i: Int32): u128 {
        if (int32::is_negative(i)) {
            get_square_price_from_tick_negative(int32::abs(i))
        } else {
            get_square_price_from_tick_positive(int32::raw_value(i))
        }
    }

    /// get sqrt(1.0001)^i, where i >= 0
    public fun get_square_price_from_tick_positive(i: u32): u128 {
        assert!(i <= 443636, E_TICK_TOO_BIG);
        let r = ONE_X_256;

        // check for 2^0
        if (i & 1 > 0) {
            r = r * 79232123823359799118286999567;
            r = r >> PRECISION;
        };

        // check for 2^1
        if (i & 2 > 0) {
            r = r * 79236085330515764027303304731;
            r = r >> PRECISION;
        };

        // check for 2^2
        if (i & 4 > 0) {
            r = r * 79244008939048815603706035061;
            r = r >> PRECISION;
        };

        // check for 2^3
        if (i & 8 > 0) {
            r = r * 79259858533276714757314932305;
            r = r >> PRECISION;
        };

        // check for 2^4
        if (i & 16 > 0) {
            r = r * 79291567232598584799939703904;
            r = r >> PRECISION;
        };

        // check for 2^5
        if (i & 32 > 0) {
            r = r * 79355022692464371645785046466;
            r = r >> PRECISION;
        };

        // check for 2^6
        if (i & 64 > 0) {
            r = r * 79482085999252804386437311141;
            r = r >> PRECISION;
        };

        // check for 2^7
        if (i & 128 > 0) {
            r = r * 79736823300114093921829183326;
            r = r >> PRECISION;
        };

        // check for 2^8
        if (i & 256 > 0) {
            r = r * 80248749790819932309965073892;
            r = r >> PRECISION;
        };

        // check for 2^9
        if (i & 512 > 0) {
            r = r * 81282483887344747381513967011;
            r = r >> PRECISION;
        };

        // check for 2^10
        if (i & 1024 > 0) {
            r = r * 83390072131320151908154831281;
            r = r >> PRECISION;
        };

        // check for 2^11
        if (i & 2048 > 0) {
            r = r * 87770609709833776024991924138;
            r = r >> PRECISION;
        };

        // check for 2^12
        if (i & 4096 > 0) {
            r = r * 97234110755111693312479820773;
            r = r >> PRECISION;
        };

        // check for 2^13
        if (i & 8192 > 0) {
            r = r * 119332217159966728226237229890;
            r = r >> PRECISION;
        };

        // check for 2^14
        if (i & 16384 > 0) {
            r = r * 179736315981702064433883588727;
            r = r >> PRECISION;
        };

        // check for 2^15
        if (i & 32768 > 0) {
            r = r * 407748233172238350107850275304;
            r = r >> PRECISION;
        };

        // check for 2^16
        if (i & 65536 > 0) {
            r = r * 2098478828474011932436660412517;
            r = r >> PRECISION;
        };

        // check for 2^17
        if (i & 131072 > 0) {
            r = r * 55581415166113811149459800483533;
            r = r >> PRECISION;
        };

        // check for 2^18
        if (i & 262144 > 0) {
            r = r * 38992368544603139932233054999993551;
            r = r >> PRECISION;
        };

        (r as u128)
    }

    /// get sqrt(1.0001)^(-i), where i >= 0
    public fun get_square_price_from_tick_negative(i: u32): u128 {
        assert!(i <= 443636, E_TICK_TOO_BIG);
        let r = (ONE_X as u256);
        if (i & 1 > 0) {
            r = r * 79224201403219477170569942573;
            r = r >> PRECISION;
        };
        if (i & 2 > 0) {
            r = r * 79220240490215316061937756560;
            r = r >> PRECISION;
        };
        if (i & 4 > 0) {
            r = r * 79212319258289487113226433916;
            r = r >> PRECISION;
        };
        if (i & 8 > 0) {
            r = r * 79196479170490597288862688490;
            r = r >> PRECISION;
        };
        if (i & 16 > 0) {
            r = r * 79164808496886665658930780291;
            r = r >> PRECISION;
        };
        if (i & 32 > 0) {
            r = r * 79101505139923049997807806614;
            r = r >> PRECISION;
        };
        if (i & 64 > 0) {
            r = r * 78975050245229982702767995059;
            r = r >> PRECISION;
        };
        if (i & 128 > 0) {
            r = r * 78722746600537056721934508529;
            r = r >> PRECISION;
        };
        if (i & 256 > 0) {
            r = r * 78220554859095770638340573243;
            r = r >> PRECISION;
        };
        if (i & 512 > 0) {
            r = r * 77225761753129597550065289036;
            r = r >> PRECISION;
        };
        if (i & 1024 > 0) {
            r = r * 75273969370139069689486932537;
            r = r >> PRECISION;
        };
        if (i & 2048 > 0) {
            r = r * 71517125791179246722882903167;
            r = r >> PRECISION;
        };
        if (i & 4096 > 0) {
            r = r * 64556580881331167221767657719;
            r = r >> PRECISION;
        };
        if (i & 8192 > 0) {
            r = r * 52601903197458624361810746399;
            r = r >> PRECISION;
        };
        if (i & 16384 > 0) {
            r = r * 34923947901690145425342545398;
            r = r >> PRECISION;
        };
        if (i & 32768 > 0) {
            r = r * 15394552875315951095595078917;
            r = r >> PRECISION;
        };
        if (i & 65536 > 0) {
            r = r * 2991262837734375505310244436;
            r = r >> PRECISION;
        };
        if (i & 131072 > 0) {
            r = r * 112935262922445818024280873;
            r = r >> PRECISION;
        };
        if (i & 262144 > 0) {
            r = r * 160982827401375763736068;
            r = r >> PRECISION;
        };

        (r as u128)
    }

    /// log_2 for log_{sqrt{1.0001}} y
    public fun log_2(y: u128): Int128 {
        assert!(y != 0, E_ZERO_FOR_LOG_2);
        let leading_zeros = more_math_u128::leading_zeros(y);
        if (y == ONE_X) {
            int128::zero()
        } else if (y > ONE_X) {
            let n_0: u8 = 128 - PRECISION - leading_zeros - 1;
            let r = (n_0 as u128) << PRECISION;
            let d = (more_math_u256::log_2((y as u256) >> n_0, PRECISION) as u128);
            int128::new(r + d, false)
        } else {
            let n_0: u8 = leading_zeros - (128 - PRECISION - 1);
            let r = (n_0 as u128) << PRECISION;
            let intpart = int128::new(r, true);
            let d = (more_math_u256::log_2((y as u256) << n_0, PRECISION) as u128);
            int128::add(int128::new(d, false), intpart)
        }
    }

    /// get the tick from sqrt price
    public fun get_tick(sqrt_p: u128): Int32 {
        let log_2_y = log_2(sqrt_p);
        let is_neg = int128::is_negative(log_2_y);
        let log_2_y = int128::abs(log_2_y);
        let ratio = if (is_neg) {
            let r = log_2_y / SQUARE_PRICE_NEG_LOG_2_ABS;
            if (r * SQUARE_PRICE_NEG_LOG_2_ABS < log_2_y) {
                r + 1
            } else {
                r
            }
        } else {
            log_2_y / SQUARE_PRICE_LOG_2
        };
        int32::new((ratio as u32), is_neg)
    }

    /// price
    public fun get_price(x: u64, y: u64): u256 {
        let x = (x as u256) << PRECISION;
        let y = (y as u256);
        x / y
    }

    /// get the sqrt price sqrt(x/y)
    public fun get_sqrt_price(x: u64, y: u64): u128 {
        let x = ((x as u256) << PRECISION) << PRECISION;
        let y = (y as u256);
        (more_math_u256::sqrt(x / y) as u128)
    }

    /// get sqrt price for a fixed point price with the same precision.
    public fun get_sqrt_price_from_price(price: u128): u128 {
        let price = (price as u256);
        price = price << PRECISION;
        let sqrt_price = more_math_u256::sqrt(price);
        (sqrt_price as u128)
    }

    /// check if this is a valid tick
    public fun is_valid_tick(tick: Int32, spacing: u32): bool {
        let abs_tick = int32::abs(tick);
        (abs_tick % spacing) == 0
    }

    /// making sure the tick spacing is between 1 and 256 inclusive.
    public fun is_valid_tick_spacing(tick_spacing: u32): bool {
        tick_spacing > 0 && tick_spacing <= 256
    }

    /// inverse returns 1/x
    public fun inverse(x: u128, round_up: bool): u128 {
        let x = (x as u256);
        let r = ONE_X_TWICE_SHIFTED_256 / x;
        if (round_up && (r * x < ONE_X_TWICE_SHIFTED_256)) {
            ((r + 1) as u128)
        } else {
            (r as u128)
        }
    }

    /// divide the fixed point number.
    public fun divide(numerator: u128, denominator: u128, round_up: bool): u128 {
        let numerator = (numerator as u256) << PRECISION;
        let denominator = (denominator as u256);
        let r = numerator / denominator;
        if (round_up && (r * denominator < numerator)) {
            ((r + 1) as u128)
        } else {
            (r as u128)
        }
    }

    #[test_only]
    public fun get_square_price_from_2_n_positive(i: u8): u128 {
        if (i == 0) {
            79232123823359799118286999567
        } else if (i == 1) {
            79236085330515764027303304731
        } else if (i == 2) {
            79244008939048815603706035061
        } else if (i == 3) {
            79259858533276714757314932305
        } else if (i == 4) {
            79291567232598584799939703904
        } else if (i == 5) {
            79355022692464371645785046466
        } else if (i == 6) {
            79482085999252804386437311141
        } else if (i == 7) {
            79736823300114093921829183326
        } else if (i == 8) {
            80248749790819932309965073892
        } else if (i == 9) {
            81282483887344747381513967011
        } else if (i == 10) {
            83390072131320151908154831281
        } else if (i == 11) {
            87770609709833776024991924138
        } else if (i == 12) {
            97234110755111693312479820773
        } else if (i == 13) {
            119332217159966728226237229890
        } else if (i == 14) {
            179736315981702064433883588727
        } else if (i == 15) {
            407748233172238350107850275304
        } else if (i == 16) {
            2098478828474011932436660412517
        } else if (i == 17) {
            55581415166113811149459800483533
        } else if (i == 18) {
            38992368544603139932233054999993551
        } else {
            abort((i as u64))
        }
    }

    #[test_only]
    public fun get_square_price_from_2_n_negative(i: u8): u128 {
        if (i == 0) {
            79224201403219477170569942573
        } else if (i == 1) {
            79220240490215316061937756560
        } else if (i == 2) {
            79212319258289487113226433916
        } else if (i == 3) {
            79196479170490597288862688490
        } else if (i == 4) {
            79164808496886665658930780291
        } else if (i == 5) {
            79101505139923049997807806614
        } else if (i == 6) {
            78975050245229982702767995059
        } else if (i == 7) {
            78722746600537056721934508529
        } else if (i == 8) {
            78220554859095770638340573243
        } else if (i == 9) {
            77225761753129597550065289036
        } else if (i == 10) {
            75273969370139069689486932537
        } else if (i == 11) {
            71517125791179246722882903167
        } else if (i == 12) {
            64556580881331167221767657719
        } else if (i == 13) {
            52601903197458624361810746399
        } else if (i == 14) {
            34923947901690145425342545398
        } else if (i == 15) {
            15394552875315951095595078917
        } else if (i == 16) {
            2991262837734375505310244436
        } else if (i == 17) {
            112935262922445818024280873
        } else if (i == 18) {
            160982827401375763736068
        } else {
            abort((i as u64))
        }
    }

    #[test]
    fun test_log_2_y() {
        assert!(int128::is_zero(log_2(ONE_X)), 1);

        // check positive side
        let square_price_0 = 79232123823359799118286999567u128;
        let ratio_0 = get_tick(square_price_0);
        let abs_ratio_0 = int32::abs(ratio_0);
        assert!(abs_ratio_0 == 1, (abs_ratio_0 as u64)); // positive

        // check positive side
        let square_price_1 = 79236085330515764027303304731u128;
        let ratio_1 = get_tick(square_price_1);
        let abs_ratio_1 = int32::abs(ratio_1);
        assert!(abs_ratio_1 == 2, (abs_ratio_1 as u64)); // positive

        // check positive side
        let square_price_2 = 79244008939048815603706035061u128;
        let ratio_2 = get_tick(square_price_2);
        let abs_ratio_2 = int32::abs(ratio_2);
        assert!(abs_ratio_2 == 4, (abs_ratio_2 as u64)); // positive

        // check positive side
        let square_price_3 = 79259858533276714757314932305u128;
        let ratio_3 = get_tick(square_price_3);
        let abs_ratio_3 = int32::abs(ratio_3);
        assert!(abs_ratio_3 == 8, (abs_ratio_3 as u64)); // positive

        // check positive side
        let square_price_4 = 79291567232598584799939703904u128;
        let ratio_4 = get_tick(square_price_4);
        let abs_ratio_4 = int32::abs(ratio_4);
        assert!(abs_ratio_4 == 16, (abs_ratio_4 as u64)); // positive

        // check positive side
        let square_price_5 = 79355022692464371645785046466u128;
        let ratio_5 = get_tick(square_price_5);
        let abs_ratio_5 = int32::abs(ratio_5);
        assert!(abs_ratio_5 == 32, (abs_ratio_5 as u64)); // positive

        // check positive side
        let square_price_6 = 79482085999252804386437311141u128;
        let ratio_6 = get_tick(square_price_6);
        let abs_ratio_6 = int32::abs(ratio_6);
        assert!(abs_ratio_6 == 64, (abs_ratio_6 as u64)); // positive

        // check positive side
        let square_price_7 = 79736823300114093921829183326u128;
        let ratio_7 = get_tick(square_price_7);
        let abs_ratio_7 = int32::abs(ratio_7);
        assert!(abs_ratio_7 == 128, (abs_ratio_7 as u64)); // positive

        // check positive side
        let square_price_8 = 80248749790819932309965073892u128;
        let ratio_8 = get_tick(square_price_8);
        let abs_ratio_8 = int32::abs(ratio_8);
        assert!(abs_ratio_8 == 256, (abs_ratio_8 as u64)); // positive

        // check positive side
        let square_price_9 = 81282483887344747381513967011u128;
        let ratio_9 = get_tick(square_price_9);
        let abs_ratio_9 = int32::abs(ratio_9);
        assert!(abs_ratio_9 == 512, (abs_ratio_9 as u64)); // positive

        // check positive side
        let square_price_10 = 83390072131320151908154831281u128;
        let ratio_10 = get_tick(square_price_10);
        let abs_ratio_10 = int32::abs(ratio_10);
        assert!(abs_ratio_10 == 1024, (abs_ratio_10 as u64)); // positive

        // check positive side
        let square_price_11 = 87770609709833776024991924138u128;
        let ratio_11 = get_tick(square_price_11);
        let abs_ratio_11 = int32::abs(ratio_11);
        assert!(abs_ratio_11 == 2048, (abs_ratio_11 as u64)); // positive

        // check positive side
        let square_price_12 = 97234110755111693312479820773u128;
        let ratio_12 = get_tick(square_price_12);
        let abs_ratio_12 = int32::abs(ratio_12);
        assert!(abs_ratio_12 == 4096, (abs_ratio_12 as u64)); // positive

        // check positive side
        let square_price_13 = 119332217159966728226237229890u128;
        let ratio_13 = get_tick(square_price_13);
        let abs_ratio_13 = int32::abs(ratio_13);
        assert!(abs_ratio_13 == 8192, (abs_ratio_13 as u64)); // positive

        // check positive side
        let square_price_14 = 179736315981702064433883588727u128;
        let ratio_14 = get_tick(square_price_14);
        let abs_ratio_14 = int32::abs(ratio_14);
        assert!(abs_ratio_14 == 16384, (abs_ratio_14 as u64)); // positive

        // check positive side
        let square_price_15 = 407748233172238350107850275304u128;
        let ratio_15 = get_tick(square_price_15);
        let abs_ratio_15 = int32::abs(ratio_15);
        assert!(abs_ratio_15 == 32768, (abs_ratio_15 as u64)); // positive

        // check positive side
        let square_price_16 = 2098478828474011932436660412517u128;
        let ratio_16 = get_tick(square_price_16);
        let abs_ratio_16 = int32::abs(ratio_16);
        assert!(abs_ratio_16 == 65536, (abs_ratio_16 as u64)); // positive

        // check positive side
        let square_price_17 = 55581415166113811149459800483533u128;
        let ratio_17 = get_tick(square_price_17);
        let abs_ratio_17 = int32::abs(ratio_17);
        assert!(abs_ratio_17 == 131072, (abs_ratio_17 as u64)); // positive

        // check positive side
        let square_price_18 = 38992368544603139932233054999993551u128;
        let ratio_18 = get_tick(square_price_18);
        let abs_ratio_18 = int32::abs(ratio_18);
        assert!(abs_ratio_18 == 262144, (abs_ratio_18 as u64)); // positive

        // check negative side
        let square_price_0 = 79224201403219477170569942573u128;
        let ratio_0 = get_tick(square_price_0);
        let abs_ratio_0 = int32::abs(ratio_0);
        assert!(abs_ratio_0 == 1, (abs_ratio_0 as u64)); // negative

        // check negative side
        let square_price_1 = 79220240490215316061937756560u128;
        let ratio_1 = get_tick(square_price_1);
        let abs_ratio_1 = int32::abs(ratio_1);
        assert!(abs_ratio_1 == 2, (abs_ratio_1 as u64)); // negative

        // check negative side
        let square_price_2 = 79212319258289487113226433916u128;
        let ratio_2 = get_tick(square_price_2);
        let abs_ratio_2 = int32::abs(ratio_2);
        assert!(abs_ratio_2 == 4, (abs_ratio_2 as u64)); // negative

        // check negative side
        let square_price_3 = 79196479170490597288862688490u128;
        let ratio_3 = get_tick(square_price_3);
        let abs_ratio_3 = int32::abs(ratio_3);
        assert!(abs_ratio_3 == 8, (abs_ratio_3 as u64)); // negative

        // check negative side
        let square_price_4 = 79164808496886665658930780291u128;
        let ratio_4 = get_tick(square_price_4);
        let abs_ratio_4 = int32::abs(ratio_4);
        assert!(abs_ratio_4 == 16, (abs_ratio_4 as u64)); // negative

        // check negative side
        let square_price_5 = 79101505139923049997807806614u128;
        let ratio_5 = get_tick(square_price_5);
        let abs_ratio_5 = int32::abs(ratio_5);
        assert!(abs_ratio_5 == 32, (abs_ratio_5 as u64)); // negative

        // check negative side
        let square_price_6 = 78975050245229982702767995059u128;
        let ratio_6 = get_tick(square_price_6);
        let abs_ratio_6 = int32::abs(ratio_6);
        assert!(abs_ratio_6 == 64, (abs_ratio_6 as u64)); // negative

        // check negative side
        let square_price_7 = 78722746600537056721934508529u128;
        let ratio_7 = get_tick(square_price_7);
        let abs_ratio_7 = int32::abs(ratio_7);
        assert!(abs_ratio_7 == 128, (abs_ratio_7 as u64)); // negative

        // check negative side
        let square_price_8 = 78220554859095770638340573243u128;
        let ratio_8 = get_tick(square_price_8);
        let abs_ratio_8 = int32::abs(ratio_8);
        assert!(abs_ratio_8 == 256, (abs_ratio_8 as u64)); // negative

        // check negative side
        let square_price_9 = 77225761753129597550065289036u128;
        let ratio_9 = get_tick(square_price_9);
        let abs_ratio_9 = int32::abs(ratio_9);
        assert!(abs_ratio_9 == 512, (abs_ratio_9 as u64)); // negative

        // check negative side
        let square_price_10 = 75273969370139069689486932537u128;
        let ratio_10 = get_tick(square_price_10);
        let abs_ratio_10 = int32::abs(ratio_10);
        assert!(abs_ratio_10 == 1024, (abs_ratio_10 as u64)); // negative

        // check negative side
        let square_price_11 = 71517125791179246722882903167u128;
        let ratio_11 = get_tick(square_price_11);
        let abs_ratio_11 = int32::abs(ratio_11);
        assert!(abs_ratio_11 == 2048, (abs_ratio_11 as u64)); // negative

        // check negative side
        let square_price_12 = 64556580881331167221767657719u128;
        let ratio_12 = get_tick(square_price_12);
        let abs_ratio_12 = int32::abs(ratio_12);
        assert!(abs_ratio_12 == 4096, (abs_ratio_12 as u64)); // negative

        // check negative side
        let square_price_13 = 52601903197458624361810746399u128;
        let ratio_13 = get_tick(square_price_13);
        let abs_ratio_13 = int32::abs(ratio_13);
        assert!(abs_ratio_13 == 8192, (abs_ratio_13 as u64)); // negative

        // check negative side
        let square_price_14 = 34923947901690145425342545398u128;
        let ratio_14 = get_tick(square_price_14);
        let abs_ratio_14 = int32::abs(ratio_14);
        assert!(abs_ratio_14 == 16384, (abs_ratio_14 as u64)); // negative

        // check negative side
        let square_price_15 = 15394552875315951095595078917u128;
        let ratio_15 = get_tick(square_price_15);
        let abs_ratio_15 = int32::abs(ratio_15);
        assert!(abs_ratio_15 == 32768, (abs_ratio_15 as u64)); // negative

        // check negative side
        let square_price_16 = 2991262837734375505310244436u128;
        let ratio_16 = get_tick(square_price_16);
        let abs_ratio_16 = int32::abs(ratio_16);
        assert!(abs_ratio_16 == 65536, (abs_ratio_16 as u64)); // negative

        // check negative side
        let square_price_17 = 112935262922445818024280873u128;
        let ratio_17 = get_tick(square_price_17);
        let abs_ratio_17 = int32::abs(ratio_17);
        assert!(abs_ratio_17 == 131072, (abs_ratio_17 as u64)); // negative

        // check negative side
        let square_price_18 = 160982827401375763736068u128;
        let ratio_18 = get_tick(square_price_18);
        let abs_ratio_18 = int32::abs(ratio_18);
        assert!(abs_ratio_18 == 262144, (abs_ratio_18 as u64)); // negative
    }

    #[test]
    fun test_inverse() {
        // check if the inverse can match back

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_0 = get_square_price_from_2_n_positive(0);
        let p_neg_0 = get_square_price_from_2_n_negative(0);
        let p_0_inverse = inverse(p_0, false);
        let diff_0 = int128::unsigned_subtract(p_0_inverse, p_neg_0);
        if (!int128::is_zero(diff_0)) {
            std::debug::print(&0);
            std::debug::print(&p_neg_0);
            std::debug::print(&p_0_inverse);
            std::debug::print(&diff_0);
        };
        let diff_0 = int128::abs(diff_0);
        assert!(diff_0 <= 1, (diff_0 as u64)); // positive index inverse

        let p_neg_0_inverse = inverse(p_neg_0, false);
        let diff_0 = int128::unsigned_subtract(p_neg_0_inverse, p_0);
        if (!int128::is_zero(diff_0)) {
            std::debug::print(&0);
            std::debug::print(&p_0);
            std::debug::print(&p_neg_0_inverse);
            std::debug::print(&diff_0);
        };
        let diff_0 = int128::abs(diff_0);
        assert!(diff_0 <= 1, (diff_0 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_1 = get_square_price_from_2_n_positive(1);
        let p_neg_1 = get_square_price_from_2_n_negative(1);
        let p_1_inverse = inverse(p_1, false);
        let diff_1 = int128::unsigned_subtract(p_1_inverse, p_neg_1);
        if (!int128::is_zero(diff_1)) {
            std::debug::print(&1);
            std::debug::print(&p_neg_1);
            std::debug::print(&p_1_inverse);
            std::debug::print(&diff_1);
        };
        let diff_1 = int128::abs(diff_1);
        assert!(diff_1 <= 1, (diff_1 as u64)); // positive index inverse

        let p_neg_1_inverse = inverse(p_neg_1, false);
        let diff_1 = int128::unsigned_subtract(p_neg_1_inverse, p_1);
        if (!int128::is_zero(diff_1)) {
            std::debug::print(&1);
            std::debug::print(&p_1);
            std::debug::print(&p_neg_1_inverse);
            std::debug::print(&diff_1);
        };
        let diff_1 = int128::abs(diff_1);
        assert!(diff_1 <= 1, (diff_1 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_2 = get_square_price_from_2_n_positive(2);
        let p_neg_2 = get_square_price_from_2_n_negative(2);
        let p_2_inverse = inverse(p_2, false);
        let diff_2 = int128::unsigned_subtract(p_2_inverse, p_neg_2);
        if (!int128::is_zero(diff_2)) {
            std::debug::print(&2);
            std::debug::print(&p_neg_2);
            std::debug::print(&p_2_inverse);
            std::debug::print(&diff_2);
        };
        let diff_2 = int128::abs(diff_2);
        assert!(diff_2 <= 1, (diff_2 as u64)); // positive index inverse

        let p_neg_2_inverse = inverse(p_neg_2, false);
        let diff_2 = int128::unsigned_subtract(p_neg_2_inverse, p_2);
        if (!int128::is_zero(diff_2)) {
            std::debug::print(&2);
            std::debug::print(&p_2);
            std::debug::print(&p_neg_2_inverse);
            std::debug::print(&diff_2);
        };
        let diff_2 = int128::abs(diff_2);
        assert!(diff_2 <= 1, (diff_2 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_3 = get_square_price_from_2_n_positive(3);
        let p_neg_3 = get_square_price_from_2_n_negative(3);
        let p_3_inverse = inverse(p_3, false);
        let diff_3 = int128::unsigned_subtract(p_3_inverse, p_neg_3);
        if (!int128::is_zero(diff_3)) {
            std::debug::print(&3);
            std::debug::print(&p_neg_3);
            std::debug::print(&p_3_inverse);
            std::debug::print(&diff_3);
        };
        let diff_3 = int128::abs(diff_3);
        assert!(diff_3 <= 1, (diff_3 as u64)); // positive index inverse

        let p_neg_3_inverse = inverse(p_neg_3, false);
        let diff_3 = int128::unsigned_subtract(p_neg_3_inverse, p_3);
        if (!int128::is_zero(diff_3)) {
            std::debug::print(&3);
            std::debug::print(&p_3);
            std::debug::print(&p_neg_3_inverse);
            std::debug::print(&diff_3);
        };
        let diff_3 = int128::abs(diff_3);
        assert!(diff_3 <= 1, (diff_3 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_4 = get_square_price_from_2_n_positive(4);
        let p_neg_4 = get_square_price_from_2_n_negative(4);
        let p_4_inverse = inverse(p_4, false);
        let diff_4 = int128::unsigned_subtract(p_4_inverse, p_neg_4);
        if (!int128::is_zero(diff_4)) {
            std::debug::print(&4);
            std::debug::print(&p_neg_4);
            std::debug::print(&p_4_inverse);
            std::debug::print(&diff_4);
        };
        let diff_4 = int128::abs(diff_4);
        assert!(diff_4 <= 1, (diff_4 as u64)); // positive index inverse

        let p_neg_4_inverse = inverse(p_neg_4, false);
        let diff_4 = int128::unsigned_subtract(p_neg_4_inverse, p_4);
        if (!int128::is_zero(diff_4)) {
            std::debug::print(&4);
            std::debug::print(&p_4);
            std::debug::print(&p_neg_4_inverse);
            std::debug::print(&diff_4);
        };
        let diff_4 = int128::abs(diff_4);
        assert!(diff_4 <= 1, (diff_4 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_5 = get_square_price_from_2_n_positive(5);
        let p_neg_5 = get_square_price_from_2_n_negative(5);
        let p_5_inverse = inverse(p_5, false);
        let diff_5 = int128::unsigned_subtract(p_5_inverse, p_neg_5);
        if (!int128::is_zero(diff_5)) {
            std::debug::print(&5);
            std::debug::print(&p_neg_5);
            std::debug::print(&p_5_inverse);
            std::debug::print(&diff_5);
        };
        let diff_5 = int128::abs(diff_5);
        assert!(diff_5 <= 1, (diff_5 as u64)); // positive index inverse

        let p_neg_5_inverse = inverse(p_neg_5, false);
        let diff_5 = int128::unsigned_subtract(p_neg_5_inverse, p_5);
        if (!int128::is_zero(diff_5)) {
            std::debug::print(&5);
            std::debug::print(&p_5);
            std::debug::print(&p_neg_5_inverse);
            std::debug::print(&diff_5);
        };
        let diff_5 = int128::abs(diff_5);
        assert!(diff_5 <= 1, (diff_5 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_6 = get_square_price_from_2_n_positive(6);
        let p_neg_6 = get_square_price_from_2_n_negative(6);
        let p_6_inverse = inverse(p_6, false);
        let diff_6 = int128::unsigned_subtract(p_6_inverse, p_neg_6);
        if (!int128::is_zero(diff_6)) {
            std::debug::print(&6);
            std::debug::print(&p_neg_6);
            std::debug::print(&p_6_inverse);
            std::debug::print(&diff_6);
        };
        let diff_6 = int128::abs(diff_6);
        assert!(diff_6 <= 1, (diff_6 as u64)); // positive index inverse

        let p_neg_6_inverse = inverse(p_neg_6, false);
        let diff_6 = int128::unsigned_subtract(p_neg_6_inverse, p_6);
        if (!int128::is_zero(diff_6)) {
            std::debug::print(&6);
            std::debug::print(&p_6);
            std::debug::print(&p_neg_6_inverse);
            std::debug::print(&diff_6);
        };
        let diff_6 = int128::abs(diff_6);
        assert!(diff_6 <= 1, (diff_6 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_7 = get_square_price_from_2_n_positive(7);
        let p_neg_7 = get_square_price_from_2_n_negative(7);
        let p_7_inverse = inverse(p_7, false);
        let diff_7 = int128::unsigned_subtract(p_7_inverse, p_neg_7);
        if (!int128::is_zero(diff_7)) {
            std::debug::print(&7);
            std::debug::print(&p_neg_7);
            std::debug::print(&p_7_inverse);
            std::debug::print(&diff_7);
        };
        let diff_7 = int128::abs(diff_7);
        assert!(diff_7 <= 1, (diff_7 as u64)); // positive index inverse

        let p_neg_7_inverse = inverse(p_neg_7, false);
        let diff_7 = int128::unsigned_subtract(p_neg_7_inverse, p_7);
        if (!int128::is_zero(diff_7)) {
            std::debug::print(&7);
            std::debug::print(&p_7);
            std::debug::print(&p_neg_7_inverse);
            std::debug::print(&diff_7);
        };
        let diff_7 = int128::abs(diff_7);
        assert!(diff_7 <= 1, (diff_7 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_8 = get_square_price_from_2_n_positive(8);
        let p_neg_8 = get_square_price_from_2_n_negative(8);
        let p_8_inverse = inverse(p_8, false);
        let diff_8 = int128::unsigned_subtract(p_8_inverse, p_neg_8);
        if (!int128::is_zero(diff_8)) {
            std::debug::print(&8);
            std::debug::print(&p_neg_8);
            std::debug::print(&p_8_inverse);
            std::debug::print(&diff_8);
        };
        let diff_8 = int128::abs(diff_8);
        assert!(diff_8 <= 1, (diff_8 as u64)); // positive index inverse

        let p_neg_8_inverse = inverse(p_neg_8, false);
        let diff_8 = int128::unsigned_subtract(p_neg_8_inverse, p_8);
        if (!int128::is_zero(diff_8)) {
            std::debug::print(&8);
            std::debug::print(&p_8);
            std::debug::print(&p_neg_8_inverse);
            std::debug::print(&diff_8);
        };
        let diff_8 = int128::abs(diff_8);
        assert!(diff_8 <= 1, (diff_8 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_9 = get_square_price_from_2_n_positive(9);
        let p_neg_9 = get_square_price_from_2_n_negative(9);
        let p_9_inverse = inverse(p_9, false);
        let diff_9 = int128::unsigned_subtract(p_9_inverse, p_neg_9);
        if (!int128::is_zero(diff_9)) {
            std::debug::print(&9);
            std::debug::print(&p_neg_9);
            std::debug::print(&p_9_inverse);
            std::debug::print(&diff_9);
        };
        let diff_9 = int128::abs(diff_9);
        assert!(diff_9 <= 1, (diff_9 as u64)); // positive index inverse

        let p_neg_9_inverse = inverse(p_neg_9, false);
        let diff_9 = int128::unsigned_subtract(p_neg_9_inverse, p_9);
        if (!int128::is_zero(diff_9)) {
            std::debug::print(&9);
            std::debug::print(&p_9);
            std::debug::print(&p_neg_9_inverse);
            std::debug::print(&diff_9);
        };
        let diff_9 = int128::abs(diff_9);
        assert!(diff_9 <= 1, (diff_9 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_10 = get_square_price_from_2_n_positive(10);
        let p_neg_10 = get_square_price_from_2_n_negative(10);
        let p_10_inverse = inverse(p_10, false);
        let diff_10 = int128::unsigned_subtract(p_10_inverse, p_neg_10);
        if (!int128::is_zero(diff_10)) {
            std::debug::print(&10);
            std::debug::print(&p_neg_10);
            std::debug::print(&p_10_inverse);
            std::debug::print(&diff_10);
        };
        let diff_10 = int128::abs(diff_10);
        assert!(diff_10 <= 1, (diff_10 as u64)); // positive index inverse

        let p_neg_10_inverse = inverse(p_neg_10, false);
        let diff_10 = int128::unsigned_subtract(p_neg_10_inverse, p_10);
        if (!int128::is_zero(diff_10)) {
            std::debug::print(&10);
            std::debug::print(&p_10);
            std::debug::print(&p_neg_10_inverse);
            std::debug::print(&diff_10);
        };
        let diff_10 = int128::abs(diff_10);
        assert!(diff_10 <= 1, (diff_10 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_11 = get_square_price_from_2_n_positive(11);
        let p_neg_11 = get_square_price_from_2_n_negative(11);
        let p_11_inverse = inverse(p_11, false);
        let diff_11 = int128::unsigned_subtract(p_11_inverse, p_neg_11);
        if (!int128::is_zero(diff_11)) {
            std::debug::print(&11);
            std::debug::print(&p_neg_11);
            std::debug::print(&p_11_inverse);
            std::debug::print(&diff_11);
        };
        let diff_11 = int128::abs(diff_11);
        assert!(diff_11 <= 1, (diff_11 as u64)); // positive index inverse

        let p_neg_11_inverse = inverse(p_neg_11, false);
        let diff_11 = int128::unsigned_subtract(p_neg_11_inverse, p_11);
        if (!int128::is_zero(diff_11)) {
            std::debug::print(&11);
            std::debug::print(&p_11);
            std::debug::print(&p_neg_11_inverse);
            std::debug::print(&diff_11);
        };
        let diff_11 = int128::abs(diff_11);
        assert!(diff_11 <= 1, (diff_11 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_12 = get_square_price_from_2_n_positive(12);
        let p_neg_12 = get_square_price_from_2_n_negative(12);
        let p_12_inverse = inverse(p_12, false);
        let diff_12 = int128::unsigned_subtract(p_12_inverse, p_neg_12);
        if (!int128::is_zero(diff_12)) {
            std::debug::print(&12);
            std::debug::print(&p_neg_12);
            std::debug::print(&p_12_inverse);
            std::debug::print(&diff_12);
        };
        let diff_12 = int128::abs(diff_12);
        assert!(diff_12 <= 1, (diff_12 as u64)); // positive index inverse

        let p_neg_12_inverse = inverse(p_neg_12, false);
        let diff_12 = int128::unsigned_subtract(p_neg_12_inverse, p_12);
        if (!int128::is_zero(diff_12)) {
            std::debug::print(&12);
            std::debug::print(&p_12);
            std::debug::print(&p_neg_12_inverse);
            std::debug::print(&diff_12);
        };
        let diff_12 = int128::abs(diff_12);
        assert!(diff_12 <= 1, (diff_12 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_13 = get_square_price_from_2_n_positive(13);
        let p_neg_13 = get_square_price_from_2_n_negative(13);
        let p_13_inverse = inverse(p_13, false);
        let diff_13 = int128::unsigned_subtract(p_13_inverse, p_neg_13);
        if (!int128::is_zero(diff_13)) {
            std::debug::print(&13);
            std::debug::print(&p_neg_13);
            std::debug::print(&p_13_inverse);
            std::debug::print(&diff_13);
        };
        let diff_13 = int128::abs(diff_13);
        assert!(diff_13 <= 1, (diff_13 as u64)); // positive index inverse

        let p_neg_13_inverse = inverse(p_neg_13, false);
        let diff_13 = int128::unsigned_subtract(p_neg_13_inverse, p_13);
        if (!int128::is_zero(diff_13)) {
            std::debug::print(&13);
            std::debug::print(&p_13);
            std::debug::print(&p_neg_13_inverse);
            std::debug::print(&diff_13);
        };
        let diff_13 = int128::abs(diff_13);
        assert!(diff_13 <= 1, (diff_13 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_14 = get_square_price_from_2_n_positive(14);
        let p_neg_14 = get_square_price_from_2_n_negative(14);
        let p_14_inverse = inverse(p_14, false);
        let diff_14 = int128::unsigned_subtract(p_14_inverse, p_neg_14);
        if (!int128::is_zero(diff_14)) {
            std::debug::print(&14);
            std::debug::print(&p_neg_14);
            std::debug::print(&p_14_inverse);
            std::debug::print(&diff_14);
        };
        let diff_14 = int128::abs(diff_14);
        assert!(diff_14 <= 1, (diff_14 as u64)); // positive index inverse

        let p_neg_14_inverse = inverse(p_neg_14, false);
        let diff_14 = int128::unsigned_subtract(p_neg_14_inverse, p_14);
        if (!int128::is_zero(diff_14)) {
            std::debug::print(&14);
            std::debug::print(&p_14);
            std::debug::print(&p_neg_14_inverse);
            std::debug::print(&diff_14);
        };
        let diff_14 = int128::abs(diff_14);
        assert!(diff_14 <= 1, (diff_14 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_15 = get_square_price_from_2_n_positive(15);
        let p_neg_15 = get_square_price_from_2_n_negative(15);
        let p_15_inverse = inverse(p_15, false);
        let diff_15 = int128::unsigned_subtract(p_15_inverse, p_neg_15);
        if (!int128::is_zero(diff_15)) {
            std::debug::print(&15);
            std::debug::print(&p_neg_15);
            std::debug::print(&p_15_inverse);
            std::debug::print(&diff_15);
        };
        let diff_15 = int128::abs(diff_15);
        assert!(diff_15 <= 1, (diff_15 as u64)); // positive index inverse

        let p_neg_15_inverse = inverse(p_neg_15, false);
        let diff_15 = int128::unsigned_subtract(p_neg_15_inverse, p_15);
        if (!int128::is_zero(diff_15)) {
            std::debug::print(&15);
            std::debug::print(&p_15);
            std::debug::print(&p_neg_15_inverse);
            std::debug::print(&diff_15);
        };
        let diff_15 = int128::abs(diff_15);
        assert!(diff_15 <= 1, (diff_15 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_16 = get_square_price_from_2_n_positive(16);
        let p_neg_16 = get_square_price_from_2_n_negative(16);
        let p_16_inverse = inverse(p_16, false);
        let diff_16 = int128::unsigned_subtract(p_16_inverse, p_neg_16);
        if (!int128::is_zero(diff_16)) {
            std::debug::print(&16);
            std::debug::print(&p_neg_16);
            std::debug::print(&p_16_inverse);
            std::debug::print(&diff_16);
        };
        let diff_16 = int128::abs(diff_16);
        assert!(diff_16 <= 1, (diff_16 as u64)); // positive index inverse

        let p_neg_16_inverse = inverse(p_neg_16, false);
        let diff_16 = int128::unsigned_subtract(p_neg_16_inverse, p_16);
        if (!int128::is_zero(diff_16)) {
            std::debug::print(&16);
            std::debug::print(&p_16);
            std::debug::print(&p_neg_16_inverse);
            std::debug::print(&diff_16);
        };
        let diff_16 = int128::abs(diff_16);
        assert!(diff_16 <= 1, (diff_16 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_17 = get_square_price_from_2_n_positive(17);
        let p_neg_17 = get_square_price_from_2_n_negative(17);
        let p_17_inverse = inverse(p_17, false);
        let diff_17 = int128::unsigned_subtract(p_17_inverse, p_neg_17);
        if (!int128::is_zero(diff_17)) {
            std::debug::print(&17);
            std::debug::print(&p_neg_17);
            std::debug::print(&p_17_inverse);
            std::debug::print(&diff_17);
        };
        let diff_17 = int128::abs(diff_17);
        assert!(diff_17 <= 1, (diff_17 as u64)); // positive index inverse

        let p_neg_17_inverse = inverse(p_neg_17, false);
        let diff_17 = int128::unsigned_subtract(p_neg_17_inverse, p_17);
        if (!int128::is_zero(diff_17)) {
            std::debug::print(&17);
            std::debug::print(&p_17);
            std::debug::print(&p_neg_17_inverse);
            std::debug::print(&diff_17);
        };
        let diff_17 = int128::abs(diff_17);
        assert!(diff_17 <= 1, (diff_17 as u64)); // negative index inverse

        ////////////////////////////////////////////////////////////////
        // check if inverse of sqrt price is from negative tick value
        let p_18 = get_square_price_from_2_n_positive(18);
        let p_neg_18 = get_square_price_from_2_n_negative(18);
        let p_18_inverse = inverse(p_18, false);
        let diff_18 = int128::unsigned_subtract(p_18_inverse, p_neg_18);
        if (!int128::is_zero(diff_18)) {
            std::debug::print(&18);
            std::debug::print(&p_neg_18);
            std::debug::print(&p_18_inverse);
            std::debug::print(&diff_18);
        };
        let diff_18 = int128::abs(diff_18);
        assert!(diff_18 <= 1, (diff_18 as u64)); // positive index inverse

        let p_neg_18_inverse = inverse(p_neg_18, false);
        let diff_18 = int128::unsigned_subtract(p_neg_18_inverse, p_18);
        if (!int128::is_zero(diff_18)) {
            std::debug::print(&18);
            std::debug::print(&p_18);
            std::debug::print(&p_neg_18_inverse);
            std::debug::print(&diff_18);
        };
        let diff_18 = int128::abs(diff_18);
        assert!(diff_18 <= 1, (diff_18 as u64)); // negative index inverse
    }
}
